// ----------
// State queues
// ----------
var queue = [];

function flushTimers() {
  let t;
  while( t = queue.shift() ){
    t();
  }
}

var activateQueue = require('./activateQueue')(flushTimers);

var waitFor = function( clbk ){
  queue.push(clbk);
  activateQueue();
  return 1;
};

///////////
// On state
///////////
let instanceCounter = 0;
let rebuiltNodes = new WeakMap();

function onState(data, options) {
  rebuiltNodes = new WeakMap();
  let root = enhanceNode( data );
  root.__.rootName = (options || {}).name || ('os' + (++instanceCounter));
  return root;
}

function enhanceNode( data ){
  if( isLeaf( data ) ){
    return data;
  }
  else if( !isOs( data ) ){
    return createOsNode( data, true );
  }
  return data;
}

function createOsNode( data, deepCreation ){
  let __ = {
    parents: isOs(data) ? new Set(data.__.parents) : new Set(),
    clbks: isOs(data) ? data.__.clbks.slice() : [],
    timer: false,
    init: true // init true to not enqueue first changes
  };
  let handlers = Object.assign( {__: __}, proxyHandlers );
  let source = deepCreation ?
    (data.splice ? [] : {} ) :
    data
  ;
  let os = new Proxy( source, handlers );

  if( deepCreation ){
    iterateKeys( data, function( key ){
      os[key] = enhanceNode( data[key] );
      if( isOs(os[key]) ){
        os[key].__.parents.add(__);
      }
    });
  }

  // From now we won't allow adding os nodes 
  // and start emitting events
  delete __.init;

  __.setDirty = function( isUpdatedNode ) {
    let hadNextState = __.nextState;

    if( !hadNextState ){
      __.nextState = createOsNode( clone( os ) );
      __.nextState.init = false;
    }
    
    if( isUpdatedNode || !hadNextState ){
      if( isRoot(os) ){
        enqueueRootChange(os);
      }
      else {
        __.parents.forEach( function(grandpa) {
          grandpa.setDirty();
        });
      }
    }
  };
  
  __.getAscendancy = function( ascendancy ){
    ascendancy.add( os );

    __.parents.forEach( parent => {
      parent.getAscendancy( ascendancy );
    });

    return ascendancy;
  }

  return os;
}

function enqueueRootChange( node ){
  if( !node.__.timer ){
    node.__.timer = waitFor( () => {
      delete node.__.timer;
      updateRoot(node);
      node.emitChange(node);
    });
  }
}

function updateRoot(root){
  rebuiltNodes = new WeakMap();

  root.__.rebuilding = 1;

  let nextState = root.__.nextState;
  delete root.__.nextState;
  for (let key in root) {
    if( nextState[key] === undefined ){
      delete root[key];
    }
  }

  // Update dirty nodes adding them to root
  iterateKeys( nextState, function( key, nextNode ){
    if( isDirty(nextNode) ){
      nextNode = settleNode( nextNode );
      transferProps( root, root[key], nextNode );
      root[key] = nextNode;
      nextNode.emitChange( nextNode );
    }
    else if( nextNode !== root[key] ){
      root[key] = nextNode;
    }
  });
  
  delete root.__.rebuilding;
}

function transferProps( parent, prevNode, nextNode ){
  let transferClbks = false;
  if( isOs(prevNode) ){
    prevNode.__.parents.delete( parent.__ );
    transferClbks = true;
  }
  if( isOs(nextNode) ){
    nextNode.__.parents.add( parent.__ );
    if( transferClbks ) {
      nextNode.__.clbks = prevNode.__.clbks.slice();
    }
  }
}

function assertNoLoops( parents, node ){
  if( isLeaf(node) ){
    return;
  }

  // Check if the parent is already added
  if( parents.has(node) ){
    err('Trying to add a node that is already added. Loops are not allowed in onState');
  }
  
  iterateKeys( node, function(key) {
    assertNoLoops( parents, node[key]);
  });
}

function settleNode( node ){
  let settled = node.__.nextState;
  delete node.__.nextState;

  // Update dirty nodes in nextState
  iterateKeys( settled, function( key, nextNode ){
    if( isDirty(nextNode) ){
      nextNode = settleNode( nextNode );
      transferProps( settled, node[key], nextNode );
      settled[key] = nextNode;
      nextNode.emitChange( nextNode );
    }
  });

  delete settled.__.init;
  return settled;
}
////////
// Proxy handlers
///////
let arrayReadMethods = new Set([
  'concat', 'copyWithin', 'entries', 'every', 'filter', 'findIndex', 'forEach', 
  'includes', 'indexOf', 'join', 'keys',
]);
var proxyHandlers = {
  set: function (obj, prop, value) {
    if( typeof value === 'function' ){
      onState.warn('Adding functions to a oS is not allowed. They will be omitted.');
      return true;
    }

    if( isRoot(value) ){
      err('Cant add root nodes to another os.');
    }

    if( this.__.rebuilding || this.__.init ){
      obj[prop] = value;
      return true;
    }

    if( !this.__.parents.size && !this.__.rootName ){
      onState.warn("Can't change detached nodes. It won't emit `state` events.");
      return true;
    }

    if( !isLeaf(value) ){
      assertNoLoops( this.__.getAscendancy( new Set() ), value );
    }
    
    let nextState = this.__.nextState;
    let nextValue = enhanceNode( value );
    if( nextState ){
      nextState[prop] = nextValue;
      // already dirty
    }
    else {
      nextState = clone( obj );
      nextState[prop] = nextValue;
      this.__.nextState = createOsNode( nextState, false );
      this.__.nextState.__.init = true;
      this.__.setDirty( true );
    }

    return true;
  },
  
  deleteProperty: function (obj, prop) {
    if (this.__.rebuilding) {
      delete obj[prop];
      return true;
    }
    
    let nextState = this.__.nextState;
    if( nextState ){
      delete nextState[prop];
    }
    else {
      nextState = {};
      for( let key in obj ){
        if( prop !== key ){
          nextState[key] = obj[key];
        }
      }
      this.__.nextState = createOsNode( nextState, false );
      this.__.nextState.__.init = true;
      this.__.setDirty( true );
    }

    return true;
  },
  get: function (obj, prop) {
    if (prop === '__') {
      return this.__;
    }
    
    let target = this.__.nextState || obj;
    if (nodeMethods[prop]) {
      return nodeMethods[prop];
    }
    if( target.splice && Array.prototype[prop] ){
      return Array.prototype[prop].bind(target);
    }
    if (target[prop] || target.hasOwnProperty(prop)) {
      return target[prop];
    }

    return Reflect.get(target, prop);
  },
  ownKeys: function (obj){
    return Reflect.ownKeys( this.__.nextState || obj );
  },
  getOwnPropertyDescriptor: function( obj, key ){
    return Object.getOwnPropertyDescriptor( this.__.nextState || obj, key );
  }
};



///////////
// Extra methods for nodes
///////////
const nodeMethods = {
  addChangeListener: function(clbk) {
    if (typeof clbk !== 'function') {
      return onState.warn("The listener is not a function.")
    }
    this.__.clbks.push( clbk );
  },
  removeChangeListener: function(clbk) {
    let clbks = this.__.clbks;
    let idx = clbks.length;
    let removed = false;

    while( idx-- > 0 ){
      if( clbk === clbks[idx] ){
        clbks.splice( idx, 1 );
        removed = true;
      }
    }

    if( !removed ){
      onState.warn("Couldn't find the listener to remove.");
    }
  },
  emitChange: function ( state ) {
    this.__.clbks.forEach( clbk => {
      clbk( state );
    });
  },
  flatten: function() {
    return JSON.parse( JSON.stringify(this) );
  }
}


////////////
// HELPERS
////////////
function isOs(data) {
  return data && data.__;
}

function isLeaf(data){
  return !(data instanceof Object);
}

function isRoot(data){
  return data && data.__ && data.__.rootName;
}

function isDirty(data){
  return isOs(data) && data.__.nextState;
}

function clone( node ){
  if (node.slice) return node.slice();

  let c = {};
  for (let key in node) {
    c[key] = node[key];
  }
  return c;
}

function iterateKeys( obj, clbk ){
  if(obj.splice){
    obj.forEach( (it, key) => clbk(key) );
  }
  for( let key in obj ){
    clbk(key, obj[key]);
  }
}

function err(msg) {
  throw new Error('onState ERROR: ' + msg);
}

onState.warn = function(msg) {
  console.warn('onState WARNING: ' + msg);
}

/* EXPORT - Do not remove or modify this comment */
module.exports = onState;